/*
 * To set up the project, install the dependencies, and run the application, follow these steps:
 *
 * 1. Install the Conductor JavaScript SDK:
 *    npm install @io-orkes/conductor-javascript
 *    or
 *    yarn add @io-orkes/conductor-javascript
 *
 * 2. Run the JavaScript file (replace yourFile.js with your actual file name):
 *    node yourFile.js
 */

// workers/pdfGeneration_worker.js
import { orkesConductorClient, TaskManager } from "@io-orkes/conductor-javascript";
import PDFDocument from "pdfkit";               // PDF generator
import { writeFile } from "fs/promises";        // to write file (for debugging if you want)
import { fileURLToPath } from "url";
import { dirname, join } from "path";

// __dirname in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Where to drop PDFs locally (optional; base64 is returned to workflow anyway)
const OUT_DIR = join(__dirname, "../out");

async function initWorker() {
  const client = await orkesConductorClient({
    TOKEN: "YOUR_TOKEN_HERE",
    serverUrl: "https://developer.orkescloud.com/api",
  });

  // Helper: build a simple PDF in memory and return Buffer
  const buildPdfBuffer = async (booking) => {
    return new Promise((resolve, reject) => {
      const doc = new PDFDocument({ size: "A4", margin: 50 });
      const chunks = [];
      doc.on("data", (c) => chunks.push(c));
      doc.on("end", () => resolve(Buffer.concat(chunks)));
      doc.on("error", reject);

      // --- PDF content ---
      doc.fontSize(20).text("Shipping Booking Confirmation", { align: "center" });
      doc.moveDown();

      // Header block
      doc.fontSize(12).text(`Booking ID: ${booking.bookingId || "N/A"}`);
      doc.text(`Timestamp : ${booking.bookingTimestamp || "N/A"}`);
      doc.moveDown();

      // Vendor block
      doc.fontSize(14).text("Vendor Details", { underline: true });
      doc.moveDown(0.5);
      doc.fontSize(12)
        .text(`Vendor        : ${booking.vendor || "N/A"}`)
        .text(`Container Size: ${booking.containerSize || "N/A"}`)
        .text(`Delivery Time : ${booking.deliveryTime || "N/A"}`)
        .text(`Price         : ${booking.price || "N/A"}`);
      doc.moveDown();

      // Message
      if (booking.bookingMessage) {
        doc.fontSize(14).text("Message", { underline: true });
        doc.moveDown(0.5);
        doc.fontSize(12).text(booking.bookingMessage);
        doc.moveDown();
      }

      // Footer
      doc.moveDown();
      doc.fontSize(10).fillColor("gray")
        .text("This is a mock invoice generated by Orkes Conductor workflow for demo purposes.", { align: "center" });

      doc.end();
    });
  };

  const pdfGenerationWorker = {
    taskDefName: "pdfGeneration",
    /**
     * inputData.vendor is expected to be the booking object from your Inline task, e.g.:
     * {
     *   bookingId, bookingTimestamp, bookingMessage,
     *   vendor, containerSize, deliveryTime, price
     * }
     */
    execute: async ({ inputData: { vendor }, taskId }) => {
      // Accept both the structured booking object OR a string (fallback)
      let booking;
      if (vendor && typeof vendor === "object") {
        booking = vendor;
      } else {
        // If a string was passed accidentally, make a minimal object
        booking = { vendor: String(vendor || ""), bookingMessage: "Booking successful!" };
      }

      // Build PDF in memory
      const pdfBuffer = await buildPdfBuffer(booking);

      // Optional: also write a local file for debugging
      const filename = `invoice_${booking.bookingId || Date.now()}.pdf`;
      const filePath = join(OUT_DIR, filename);
      try {
        await writeFile(filePath, pdfBuffer); // comment out if you don’t want local writes
      } catch {
        // ignore local write errors (directory might not exist in some environments)
      }

      // Return base64 so downstream tasks (store/email) can use it directly
      const pdfBase64 = pdfBuffer.toString("base64");

      return {
        outputData: {
          bookingSummary: {
            bookingId: booking.bookingId || null,
            vendor: booking.vendor || null,
            containerSize: booking.containerSize || null,
            deliveryTime: booking.deliveryTime || null,
            price: booking.price || null,
            bookingTimestamp: booking.bookingTimestamp || null,
            bookingMessage: booking.bookingMessage || null,
          },
          pdf: {
            filename,
            base64: pdfBase64,
            // filePath is optional and only useful if the worker host can access the filesystem
            filePath
          }
        },
        status: "COMPLETED",
      };
    },
  };

  const manager = new TaskManager(client, [pdfGenerationWorker], {
    options: { pollInterval: 100, concurrency: 1 },
  });

  manager.startPolling();
  console.log("✅ Worker 'pdfGeneration' started and polling for tasks...");
}

initWorker();
