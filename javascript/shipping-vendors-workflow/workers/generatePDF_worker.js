/*
 * To set up the project, install the dependencies, and run the application, follow these steps:
 *
 * 1. Install the Conductor JavaScript SDK:
 *    npm install @io-orkes/conductor-javascript
 *    or
 *    yarn add @io-orkes/conductor-javascript
 *
 * 2. Run the JavaScript file (replace yourFile.js with your actual file name):
 *    node yourFile.js
 */

// workers/pdfGeneration_worker.js
import { TaskManager } from "@io-orkes/conductor-javascript";
import { getConductorClient } from "../config/conductorClient.js"; // <-- use shared client creator
import PDFDocument from "pdfkit";
import { mkdir, writeFile } from "fs/promises";
import { fileURLToPath } from "url";
import { dirname, join } from "path";

// __dirname in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Local output directory for PDFs
const OUT_DIR = join(__dirname, "../pdf");

/**
 * Ensure the output folder exists (safe to call every time).
 */
async function ensureOutDir() {
  try { await mkdir(OUT_DIR, { recursive: true }); } catch { /* ignore */ }
}

/**
 * Build a PDF (in-memory Buffer) from booking details and extra inputs.
 * booking: { bookingId, bookingTimestamp, bookingMessage, vendor, containerSize, deliveryTime, price }
 * extras:  { sku, units, origin, destination }
 */
async function buildPdfBuffer(booking, extras) {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({ size: "A4", margin: 50 });
    const chunks = [];
    doc.on("data", c => chunks.push(c));
    doc.on("end", () => resolve(Buffer.concat(chunks)));
    doc.on("error", reject);

    // Title
    doc.fontSize(20).text("Shipping Booking Confirmation", { align: "center" });
    doc.moveDown();

    // Header (IDs / timestamps)
    doc.fontSize(12)
      .text(`Booking ID : ${booking.bookingId || "N/A"}`)
      .text(`Timestamp  : ${booking.bookingTimestamp || "N/A"}`);
    doc.moveDown();

    // Vendor / Quote section
    doc.fontSize(14).text("Vendor & Quote", { underline: true });
    doc.moveDown(0.5);
    doc.fontSize(12)
      .text(`Vendor        : ${booking.vendor || "N/A"}`)
      .text(`Container Size: ${booking.containerSize || "N/A"}`)
      .text(`Delivery Time : ${booking.deliveryTime || "N/A"}`)
      .text(`Price         : ${booking.price || "N/A"}`);
    doc.moveDown();

    // Order inputs
    const routeText = `${extras.origin || "N/A"} to ${extras.destination || "N/A"}`;
    doc.fontSize(14).text("Order Inputs", { underline: true });
    doc.moveDown(0.5);
    doc.fontSize(12)
      .text(`SKU         : ${extras.sku || "N/A"}`)
      .text(`Units       : ${extras.units || "N/A"}`)
      .text(`Origin      : ${extras.origin || "N/A"}`)
      .text(`Destination : ${extras.destination || "N/A"}`)
      .text(`Route       : ${routeText}`);
    doc.moveDown();

    // Optional message from booking step
    if (booking.bookingMessage) {
      doc.fontSize(14).text("Message", { underline: true });
      doc.moveDown(0.5);
      doc.fontSize(12).text(booking.bookingMessage);
      doc.moveDown();
    }

    // Footer note
    doc.moveDown();
    doc.fontSize(10).fillColor("gray")
      .text("This is a mock invoice generated by an Orkes Conductor workflow.", { align: "center" });

    doc.end();
  });
}

async function initWorker() {
  // Use the shared client that reads TOKEN from .env.local via config/conductorClient.js
  const client = await getConductorClient();

  const pdfGenerationWorker = {
    taskDefName: "pdfGeneration",
    /**
     * Expected inputs:
     * - vendor (object): { bookingId, bookingTimestamp, bookingMessage, vendor, containerSize, deliveryTime, price }
     * - SKU (string)
     * - units (string | number)
     * - origin (string)
     * - destination (string)
     */
    execute: async ({ inputData: { vendor, SKU, units, origin, destination } }) => {
      // Normalize the booking object (be permissive if a string sneaks in)
      const booking = (vendor && typeof vendor === "object")
        ? vendor
        : { vendor: String(vendor || ""), bookingMessage: "Booking successful!" };

      // Normalize extras
      const extras = {
        sku: SKU ?? "N/A",
        units: (units ?? "N/A").toString(),
        origin: origin ?? "N/A",
        destination: destination ?? "N/A",
      };

      // Ensure output dir exists
      await ensureOutDir();

      // Build PDF and save it locally
      const pdfBuffer = await buildPdfBuffer(booking, extras);
      const filename = `invoice_${booking.bookingId || Date.now()}.pdf`;
      const filePath = join(OUT_DIR, filename);
      await writeFile(filePath, pdfBuffer);

      // Return only what downstream needs: path + structured summary (no base64)
      return {
        outputData: {
          bookingSummary: {
            bookingId: booking.bookingId || null,
            vendor: booking.vendor || null,
            containerSize: booking.containerSize || null,
            deliveryTime: booking.deliveryTime || null,
            price: booking.price || null,
            bookingTimestamp: booking.bookingTimestamp || null,
            bookingMessage: booking.bookingMessage || null,
            SKU: extras.sku,
            units: extras.units,
            origin: extras.origin,
            destination: extras.destination,
            route: `${extras.origin} to ${extras.destination}`,
          },
          pdf: {
            filename,
            filePath,
            saveMessage: `PDF saved successfully at ${filePath}`
          },
          // Audit trail with UTC timestamp for consistent logging across environments
          audit: `PDF successfully generated on ${new Date().toISOString()} UTC`
        },
        status: "COMPLETED",
      };
    },
  };

  // Start polling
  const manager = new TaskManager(client, [pdfGenerationWorker], {
    options: { pollInterval: 100, concurrency: 1 },
  });
  manager.startPolling();
  console.log("âœ… Worker 'pdfGeneration' started and polling for tasks...");
}

initWorker();
